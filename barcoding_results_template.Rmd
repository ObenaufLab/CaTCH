---
title: "CaTCH report"
author: "Kimon Froussios"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output:
  html_document:
    code_folding: hide
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
# params:
#   counts: './null'       # provide valid counts file with all the samples.
#   summaries: './null'    # provide valid summaries file with all the samples.
#   hammdist: '`r NULL`'   # provide valid tidy table for the hamming distance histograms
#   outpref: './null'      # provide a destination for the output table
#   samples: '`r NULL`'    # provide valid file listing samples, groups, conditions and assigned colours.
#   refsamps: 1            # Which samples to use as reference abundances for naming the barcodes (as listed in the file provided for the samples parameter).
#   count_thresh: 10       # Barcodes with counts below this will be discarded.
#   abund_thresh: 0.005     # Barcodes exceeding this proportional representation are considered top hits.
#   extra_bc: '`r NULL`'   # Comma-separated list of manually selected barcode IDs.
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)

library(data.table)
library(magrittr)
library(dplyr)
library(ggplot2)
library(plotly)
library(ggrepel)
library(ggridges)
library(RColorBrewer)
library(patchwork)

params <- list(counts = opt$countsFile, summaries = opt$summariesFile, hammdist=opt$hammingFile, samples = opt$covars, outpref = file.path(opt$resultsDir, sub('.txt|.tsv', '', basename(opt$countsFile))), refsamps=opt$refsamps, abund_thresh=opt$abund_thresh, count_thresh=opt$count_thresh, extra_bc= opt$extrabc, hammdist = opt$hammdist )

# ggplot2 theme.
gth <- theme(axis.line.x= element_line(),
	         axis.line.y= element_line(),
	         strip.background= element_rect(fill= "grey95"),
	         strip.text.y= element_text(size= rel(1.2)),
	         strip.text.x= element_text(size= rel(1.1)),
	         panel.background= element_rect(fill = "white"),
	         panel.grid.major = element_line(colour="grey95"),
	         panel.grid.minor= element_blank(),
	         legend.key = element_rect(fill = 'white'),
	         plot.margin = unit(c(0.3, 1, 0.3, 0.3),"cm"),
	         axis.text.x = element_text(angle=90, hjust=1),
	         legend.position = "none"
)

mycolours <- c(
	"#bb6600", "#880000", "#bb3300", "#ff0000", "#ff9900", "#ffcc00", "#eedd00",
	"#0000ff", "#0066ff", "#0099ff", "#00ccff",  "#00ffff",
	"#5500aa", "#8800ff", "#8866ff", "#ee00bb", "#ff66ff",  "#ff99ff", "#ffccff",  
	
	"#224400", "#226600", "#229900", "#22cc00", "#22ff00", "#88cc00", 
	"#8899aa",
	"#0033aa", "#0066aa", "#0099aa", "#00ccaa", 
	"#886600", "#bb9900", "#889900", 
	"#8800aa", "#8866aa", "#8899ff", "#88ccff", 
	"#ff7700", "#ee99aa", "#eeccaa"
)

# This works best when the colours are in a sensible sequence of gradual change.
getPalette <- colorRampPalette(mycolours[1:25])

# Reshuffle colours for more contrast at low usage in the plots.
mycolours <- mycolours[c(2,8,13,20, 3,9,14,21, 1,10,15,22, 4,11,16,23, 
												 5,12,17,24, 6,18,25, 7,19,26, 
												 27,31,34,38, 28,32,35,39, 29,33,36,40, 30,37)]

# Thresholds
count_thresh = params$count_thresh
abund_thresh <- params$abund_thresh
```

Several plots in this report are interactive, so be sure to hover your pointer over them!

# Preparation

```{r inputs, result="hide", message=FALSE}
# Data
counts <- fread(params$counts)
summaries <- fread(params$summaries)
if (!is.null(params$hammdist)) {
  hammdist <- fread(params$hammdist)
}

# Output
statsout <- params$statsout

# Set sample order.
samples_tidy <- fread(params$samples)
samples_tidy[, Sample := factor(Sample, ordered=TRUE, levels=Sample)]

# Set treatment colours
sampleNames <- as.character(samples_tidy$Sample)
tc <- unique(samples_tidy[, .(Treatment, Colour)])
treatCols <- tc$Colour
names(treatCols) <- tc$Treatment
samples_tidy[, Colour := NULL]
treatCols <- c(treatCols, bc='white')

# If summaries only has one column of values (ie. one BAM file, or already in long format)
if (length(summaries) == 2) {
    names(summaries) <- c('row_ID', 'reads')
    summaries[, file := sub('_barcode-counts.txt|_barcode-counts.tsv', '', basename(params$counts), perl=TRUE)]
} else {
  names(summaries)[1] <- 'row_ID' # need a stable name I can reference
  summaries <- melt(summaries, id.vars = "row_ID", variable.name = "file", value.name = "reads")
}

# Reorder/select samples.
counts <- counts[, c('barcode', sampleNames), with=FALSE]
summaries <- summaries[row_ID %in% c("BCUnmatched", "EmptyVector", "SampleUnknown", "SpikeIn", sampleNames)]
if (!is.null(params$hammdist)) {
  hammdist <- hammdist[Sample %in% sampleNames, ]
  hammdist[, Sample := ordered(Sample, levels=sampleNames)]
}

# Assign a numeric ID to barcodes by abundance in the designated samples. +1 is to skip the first column which is barcodes.
if (!is.null(params$refsamps)){
	rs <- params$refsamps
} else {
	rs <- 1
}
counts[, meanref := rowMeans(counts[, rs+1, with=FALSE])]
setorder(counts, -meanref)
counts[, bc_id := 1:nrow(counts)]
setkey(counts, bc_id)
counts[, meanref := NULL]

# Get rid of barcodes not seen in any of the samples (as a result of subsetting the samples).
# Do this after assigning bc_ids so bc_id is consistent across different analyses with the same reference samples.
l1 <- nrow(counts)
counts <- counts[rowSums(counts[, 2:length(counts)]) != 0, ]
message(paste(l1 - nrow(counts), "BCs not seen at all among this selection of samples."))

# Vector of counts columns.
cntCols <- 2:(length(counts)-1)
```

```{r tidydata}
# Number of reads and number of detected barcodes in each sample.
libsizes <- sapply(counts[, cntCols, with=FALSE], sum)
numBarcodes <- sapply(counts[, cntCols, with=FALSE], function (x) { sum(x>0) } )

# Barcode abundances as fractions of the library sizes
relative <- as.data.table(lapply(names(counts[, -1, with=FALSE]), function(x) {
                                  if (x=='bc_id') {
                                    return(counts$bc_id)
                                  } else {
                                    return(counts[[x]] / libsizes[x])
                                  }} ))
names(relative) <- names(counts[, -1, with=FALSE])
setkey(relative, bc_id)
relative_tidy <- melt(relative, id.vars='bc_id', variable.name="Sample", value.name="Proportion")
relative_tidy[, Sample := factor(relative_tidy$Sample, levels=sampleNames, ordered=TRUE)]
setorder(relative_tidy, Sample)

# Tidy counts
counts_tidy <- melt(counts[, 2:length(counts)], id.vars=c('bc_id'), variable.name="Sample", value.name="Reads")
counts_tidy[, Sample := factor(counts_tidy$Sample, levels=sampleNames, ordered=TRUE)]
setorder(counts_tidy, Sample, bc_id)

# Now bring it all together.
all_tidy <- merge(counts_tidy, relative_tidy, by=c("bc_id", "Sample"), all=TRUE)
all_tidy[, Sample := factor(all_tidy$Sample, levels=sampleNames, ordered=TRUE)]
setorder(all_tidy, Sample, bc_id )

counts[, bc_id := paste0('bc', bc_id)]
bclevels <- counts[, bc_id]
counts[, bc_id := factor(bc_id, ordered=TRUE, levels=bclevels)]
all_tidy[, bc_id := factor(paste0('bc', bc_id), ordered=TRUE, levels=bclevels)]
counts_tidy[, bc_id := factor(paste0('bc', bc_id), ordered=TRUE, levels=bclevels)]
```

# Overview of the number of reads allocated per sample

```{r demux, fig.height=6, fig.width=7}
summaries[, total := sum(.SD$reads), by=file]
summaries[, rate := reads / total]
names(summaries)[1] <- "sample"
summaries <- summaries[reads > 0,]
# summaries$file <- ordered(summaries$file, labels=sampleNames)

clr <- getPalette(length(unique(summaries$sample)))
names(clr) <- unique(summaries$sample)
clr[c("BCUnmatched", "EmptyVector", "SampleUnknown")] <- c("black", "white", "grey50")

pdemux <- ggplot(summaries) +
    geom_bar(aes(x=file, y=rate, fill=sample), stat="identity", position="stack", colour='black', size=0.25) +
    scale_fill_manual(values=clr) +
    labs(title="Efficiency of barcode detection and sample demultiplication", x='File', y='Fraction of reads') +
    gth + theme(legend.position = "right",
    						axis.title.x = element_blank())

ggplotly( pdemux, dynamicTicks = TRUE)
```

# Number of reads and barcodes

```{r bcabund, fig.height=8, fig.width=8}
# Distribution of barcodes by read-count.
pbcdist1 <- ggplot(all_tidy, aes(x=Reads+0.01, colour=Sample, fill=Sample)) +
	geom_density_ridges(aes(y=Sample), alpha=0.4, scale=1) +
	geom_vline(xintercept=params$count_thresh, linetype='dotted') +
	scale_x_log10() +
	annotation_logticks(sides="b") +
	scale_colour_manual(values=mycolours) +
	scale_fill_manual(values=mycolours) +
	labs(x='Reads', y='Amount of Barcodes', title="Barcode abundances", subtitle='including non-detected BCs') +
	theme_classic() +
	theme(panel.grid.minor=element_blank(),
				legend.position='none')

pbcdist2 <- ggplot(all_tidy[Reads > 0, ], aes(x=Reads, colour=Sample, fill=Sample)) +
	geom_density_ridges(aes(y=Sample), alpha=0.4, scale=1) +
	geom_vline(xintercept=params$count_thresh, linetype='dotted') +
	scale_x_log10() +
	annotation_logticks(sides="b") +
	scale_colour_manual(values=mycolours) +
	scale_fill_manual(values=mycolours) +
	labs(x='Reads', y=NULL, subtitle='only detected BCs') +
	theme_classic() +
	theme(panel.grid.minor=element_blank(),
				axis.text.y= element_blank(),
				legend.position='none')

print( pbcdist1 | pbcdist2 )
```

```{r bcthresh, fig.height=5, fig.width=8}
# Effect of readcount threshold on number of barcodes.
bcbythresh <- Reduce(rbind, lapply(c(1:9, seq(10, 10000, 10)), function(x){
		dt <- all_tidy[Reads >= x, nrow(.SD), by=Sample]    # In long format, every row is one barcode in one sample
		dt[, threshold := x]
	}) )

pbccount1 <- ggplot(bcbythresh, aes(x=threshold, y=V1, colour=Sample)) +
	geom_line() +
	geom_vline(xintercept=params$count_thresh, linetype='dotted') +
	scale_x_log10() +
	annotation_logticks(sides="b") +
	scale_colour_manual(values=mycolours) +
	# coord_cartesian(xlim=c(1, NULL), ylim=c(1, NULL)) +
	labs(x='Read-count threshold', y='Barcodes') +
	theme(panel.grid.minor=element_blank(),
				legend.position="none")

pbccount2 <- ggplot(bcbythresh, aes(x=threshold, y=V1, colour=Sample)) +
	geom_line() +
	geom_vline(xintercept=params$count_thresh, linetype='dotted') +
	scale_x_log10() +
	scale_y_log10() +
	annotation_logticks(sides="lb") +
	scale_colour_manual(values=mycolours) +
	# coord_cartesian(xlim=c(1, NA), ylim=c(1, NA)) +
	labs(x='Read-count threshold', y='Barcodes') +
	theme(panel.grid.minor=element_blank(),
				legend.position="bottom")

print( pbccount1 | pbccount2 )

# Effect of proportion threshold on number of top barcodes.
bcbythresh <- Reduce(rbind, lapply(c(seq(0, 1e-1, 1e-2), seq(0, 1e-2, 1e-3), seq(0, 1e-3, 1e-4), seq(0, 1e-4, 1e-5), seq(0, 1e-5, 1e-6)), function(x){
		dt <- all_tidy[Proportion >= x, nrow(.SD), by=Sample]    # In long format, every row is one barcode in one sample
		dt[, threshold := x]
	}) )

pbcpct1 <- ggplot(bcbythresh, aes(x=threshold, y=V1, colour=Sample)) +
	geom_line() +
	geom_vline(xintercept=params$abund_thresh, linetype='dotted') +
	scale_y_log10() +
	annotation_logticks(sides="l") +
	scale_colour_manual(values=mycolours) +
	labs(x='Proportion threshold', y='Top Barcodes') +
	theme(panel.grid.minor=element_blank(),
				legend.position='none')

pbcpct2 <- ggplot(bcbythresh, aes(x=threshold, y=V1, colour=Sample)) +
	geom_line() +
	geom_vline(xintercept=params$abund_thresh, linetype='dotted') +
	scale_y_log10() +
	scale_x_log10() +
	annotation_logticks(sides="bl") +
	scale_colour_manual(values=mycolours) +
	labs(x='Proportion threshold', y='Top Barcodes') +
	theme(panel.grid.minor=element_blank(),
				legend.position='bottom')

print( pbcpct1 | pbcpct2 )
```

```{r categories}
all_tidy[, count_Good := Reads >= count_thresh]
if(!is.null(params$refsamps)){
	all_tidy[, refcount_Good := FALSE]
	goodbc <- all_tidy[Sample %in% sampleNames[params$refsamps] & count_Good, bc_id]
	all_tidy[bc_id %in% goodbc, refcount_Good := TRUE]
} else{
	all_tidy[, refcount_Good := TRUE]
}
all_tidy[, prop_Top := Proportion >= abund_thresh]

# Bring in the sample metadata
all_tidy <- merge(all_tidy, samples_tidy, by="Sample", all=TRUE)
```

Reads, barcodes, count-filtered barcodes, and top-percentage barcodes.

```{r overview, fig.height=8, fig.width=8}
message(paste( length(unique(all_tidy[, bc_id])), "barcode sequences overall."  ))
if(!is.null(params$refsamps)){
	message(paste( length(unique(all_tidy[(refcount_Good), bc_id])), "barcode sequences with good readcount in the reference(s)."  ))
	message(paste( length(unique(all_tidy[(refcount_Good & count_Good), bc_id])), "barcode sequences with good readcount in the reference(s) and good readcount in a treatment."  ))
	message(paste( length(unique(all_tidy[(!refcount_Good & count_Good), bc_id])), "barcode sequences with bad readcount in the reference(s) and good readcount in a treatment."  ))
	message("Barcodes that don't have good readcount in the references are removed from the analysis.")
	all_tidy <- all_tidy[(refcount_Good), ]
}

# Make tidy summary of counts.
count_summary <- Reduce(function(x, y){merge(x,y, by='Sample', all=TRUE)},
			list(all_tidy[, c(sum(Reads)), by=Sample],
					 all_tidy[Reads>0, .N, by=Sample],
					 all_tidy[(count_Good), .N, by=Sample],
					 all_tidy[(count_Good & prop_Top), .N, by=Sample]) )
setnames(count_summary, c("Sample", "Reads", "BCs", "BCs_fltr", "BCs_top"))

fwrite(count_summary, file=paste0(params$outpref, '_summary.tsv'), sep="\t", quote=FALSE)


count_summary <- melt(count_summary, id.vars=c("Sample"), value.name="Count", variable.name="Type")
# Pad the filtered values to maintain Y axis
count_summary[, category := Type]
pcount <- ggplot(data=count_summary, aes(x=Sample, y=Count, fill=Type))  +
            facet_grid(Type ~ ., scales = "free", switch='y') +
						geom_hline(yintercept=0, size=0.4) +
            geom_bar(stat='identity', width=0.7, size=0.2) +
            scale_fill_manual(values = c(BCs_top = "darkgoldenrod1",
            														 BCs_fltr = "darkgoldenrod3",
            														 BCs = "darkgoldenrod4",
                                         Reads= "black")) +
            scale_y_continuous(expand=c(0, 0.15), limits = c(0, NA)) +
            labs(x=NULL, y=NULL) +
            gth + theme(legend.position = "none",
            						strip.placement='outside')

ggplotly( pcount ) # , dynamicTicks = TRUE  cannot handle the categorical x-axis.
```



# Correlations

Correlate the proportional abundances, using only the barcodes that are on average above the count threshold in the reference sample(s).

```{r, fig.height=7, fig.width=16}
cf <- dcast(all_tidy[, ], bc_id ~ Sample, value.var='Proportion', fill=NA_integer_)
cat(paste('Number of barcodes used:', nrow(cf)))



my_pairwise_internal_corels <- function(mat, samples = samples_tidy$Sample, method = "spearman", prefix=params$outpref, txs=4) {
  # Correlations
  cormat <- cor(mat, method=method)
  
  # Cluster
  hcfit <- hclust(dist(scale(cormat, center=TRUE)))
  rn <- rownames(cormat)
  cormat <- cormat[samples, samples]                    # Supplied order
  cormat2 <- cormat                                     # Duplicate on which to delete the diagonal with original order.
  cormat3 <- cormat[rn[hcfit$order], rn[hcfit$order]]   # Duplicate in clustered order.
  cormat4 <- cormat3                                    # duplicate on which to delete the diagonal with in clustered order.
  
  # Delete diagonal half for the numeric labels.
  for (r in 1:nrow(cormat2)) {
    for (c in 1:ncol(cormat2)) {
      if (c <= r) {
        cormat2[r, c] <- NA_real_
      }
    }
  }
  for (r in 1:nrow(cormat4)) {
    for (c in 1:ncol(cormat4)) {
      if (c <= r) {
        cormat4[r, c] <- NA_real_
      }
    }
  }
  
  # Restructure for plotting.
  rn <- rownames(cormat)
  cormat <- as.data.table(cormat)
  cormat[, observation1 := factor(rn, ordered=TRUE, levels=rn)]
  cormat <- melt(cormat, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat[, observation2 := factor(observation2, ordered=TRUE, levels=rn)]
  
  rn2 <- rownames(cormat2)
  cormat2 <- as.data.table(cormat2)
  cormat2[, observation1 := factor(rn2, ordered=TRUE, levels=rn2)]
  cormat2 <- melt(cormat2, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat2[, observation2 := factor(observation2, ordered=TRUE, levels=rn2)]
  cormat2 <- cormat2[!is.na(Correlation)]
  
  rn3 <- rownames(cormat3)
  cormat3 <- as.data.table(cormat3)
  cormat3[, observation1 := factor(rn3, ordered=TRUE, levels=rn3)]
  cormat3 <- melt(cormat3, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat3[, observation2 := factor(observation2, ordered=TRUE, levels=rn3)]
  
  rn4 <- rownames(cormat4)
  cormat4 <- as.data.table(cormat4)
  cormat4[, observation1 := factor(rn3, ordered=TRUE, levels=rn4)]
  cormat4 <- melt(cormat4, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat4[, observation2 := factor(observation2, ordered=TRUE, levels=rn4)]
  cormat4 <- cormat4[!is.na(Correlation)]
  
  # Text colour switch for the dynamic range
  m <- min(cormat4$Correlation, na.rm=TRUE)
  M <- max(cormat4$Correlation, na.rm=TRUE)
  colourswitch <- c( m + 0.49 * (M-m),  m + 0.51 * (M-m) )
  
  
  # Square. Custom order. No values. Full range.
  p1 <- ggplot(cormat, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  # Square. Custom order. No values. Dynamic range.
  p1a <- ggplot(cormat, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "forestgreen" ) +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  # Triangle. Custom order. With values. Full range.
  p2 <- ggplot(cormat2, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=Correlation >= -0.60 & Correlation <= 0.60 ), size=rel(txs)) +
    scale_x_discrete(position = "top") +
    scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
    scale_colour_manual(values=c('FALSE'="black", 'TRUE'="white"), na.value="forestgreen", guide="none") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  # Triangle. Custom order. With values. Dynamic range.
  p2a <- ggplot(cormat2, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=(Correlation <= colourswitch[2]) ), size=rel(txs)) +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "transparent" ) +
    scale_colour_manual(values=c("black", "white"), na.value="transparent", guide="none") +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  # Square. Custom order. With values. Full range.
  p12 <- ggplot(cormat, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(data=cormat2, aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=Correlation >= -0.60 & Correlation <= 0.60 ), size=rel(txs)) +
    scale_x_discrete(position = "top") +
    scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
    scale_colour_manual(values=c('FALSE'="black", 'TRUE'="white"), na.value="forestgreen", guide="none") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  # Square. Custom order. With values. Dyhamic range.
  p12a <- ggplot(cormat, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(data=cormat2, aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=(Correlation <= colourswitch[2]) ), size=rel(txs)) +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "transparent" ) +
    scale_colour_manual(values=c("black", "white"), na.value="transparent", guide="none") +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  
  # Square. Clustered order. No values. Full range.
  p3 <- ggplot(cormat3, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  # Square. Clustered order. No values. Dyhamic range.
  p3a <- ggplot(cormat3, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "forestgreen" ) +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  # Triangle. Clustered order. with values. Full range.
  p4 <- ggplot(cormat4, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=Correlation >= -0.60 & Correlation <= 0.60 ), size=rel(txs)) +
    scale_x_discrete(position = "top") +
    scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
    scale_colour_manual(values=c('FALSE'="black", 'TRUE'="white"), na.value="forestgreen", guide="none") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  # Triangle. Clustered order. with values. Dyhamic range.
  p4a <- ggplot(cormat4, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=(Correlation <= colourswitch[2]) ), size=rel(txs)) +
    scale_x_discrete(position = "top") +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "transparent" ) +
    scale_colour_manual(values=c("black", "white"), na.value="transparent", guide="none") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  # Square. Clustered order. With values. Full range.
  p34 <- ggplot(cormat3, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(data=cormat4, aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=Correlation >= -0.60 & Correlation <= 0.60 ), size=rel(txs)) +
    scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
    scale_colour_manual(values=c('FALSE'="black", 'TRUE'="white"), na.value="forestgreen", guide="none") +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  # Square. Clustered order. With values. Dyhamic range.
  p34a <- ggplot(cormat3, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(data=cormat4, aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=(Correlation <= colourswitch[2]) ), size=rel(txs)) +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "forestgreen" ) +
    scale_colour_manual(values=c("black", "white"), na.value="transparent", guide="none") +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  fwrite(dcast(cormat2, observation1 ~ observation2, value.var = "Correlation"),
         file=paste0(prefix, '_cor.txt'),
         sep='\t', quote = FALSE, row.names = FALSE, col.names = TRUE)
  
  
  return( list(sfrnc=p1, tfrnc=p2, frnc=p12,
               sdrnc=p1a, tdrnc=p2a, drnc=p12a,
               sfrc=p3, tfrc=p4, frc=p34,
               sdrc=p3a, tdrc=p4a, drc=p34a) )
}

cplots <- my_pairwise_internal_corels(mat = cf[,2:length(cf)], method='spearman', prefix=paste0(params$outpref, '_spearman'))
print( cplots[["frnc"]] + cplots[["drc"]] )
```

# Distribution of barcode abundances

Only barcodes that passed the read-count filter are shown.

```{r proportions}
# ALSO EDIT: If this plot is changed, the same plot in the PDF chunk at the end of the report should be updated to match!
pviol <- all_tidy %>%
    filter(count_Good) %>%
    ggplot(aes(x=Sample, y=Proportion)) +
      geom_violin(aes(fill=Treatment), width=1) +
      geom_boxplot(fill="white", width=0.1, outlier.colour = 'transparent') +
      geom_hline(yintercept = abund_thresh, linetype='dotted') +
      scale_y_log10() +
			annotation_logticks(base=10, sides='l') +
      scale_fill_manual(values=treatCols) +
      labs(title="Barcode abundances", subtitle=paste("for barcodes with at least", count_thresh, "reads"), x='') +
  		gth

print ( pviol )
```

# Barcode Complexity

Number of barcodes passing the counts threshold (X-axis) vs. number of barcodes passing the proportion threshold (Y-axis).

```{r complexity_plot}
# The labels can create terrible clutter if the plot is small with lots of points.
# Plotly enables hover-over to get Sample info

pcomplex2 <- ggplot(data=all_tidy %>% filter(count_Good) %>% group_by(Sample) %>% summarise(n_Barcodes=n(), n_TopBarcodes=sum(prop_Top), Treatment=unique(Treatment)),
         aes(label=Sample, x=n_Barcodes, y=n_TopBarcodes, colour=Treatment)) +
    geom_point(shape=16, alpha=0.6) +
    scale_colour_manual(values=treatCols) +
    ggtitle("Barcode Diversity") +
    gth

ggplotly( pcomplex2, dynamicTicks = TRUE )
```


```{r complexity}
# Identify shared top barcodes
sharedBarcodes <- all_tidy[(prop_Top), .N, by=bc_id][N>1, ]
sharedBarcodesGrp <- all_tidy[(prop_Top), .N, by=c("Group", "bc_id")][N>1, ]
sharedBarcodesTrt <- all_tidy[(prop_Top), .N, by=c("Treatment", "bc_id")][N>1, ]
setorder(sharedBarcodes, -N)
setorder(sharedBarcodesGrp, -N)
setorder(sharedBarcodesTrt, -N)

if (nrow(sharedBarcodes) > 0){
	sharedBarcodes <- Reduce(rbind,
				 apply(sharedBarcodes, 1, function(x){
				 	all_tidy[prop_Top & bc_id==x['bc_id'], .(.N, paste(Sample, collapse = " ; ")), by=bc_id]
				 	})
	)
	setnames(sharedBarcodes, c("bc_id", "nShared", "Samples"))
	all_tidy <- merge(all_tidy, sharedBarcodes[, .(bc_id, nShared)], by="bc_id", all=TRUE)
} else {
	message("No shared Barcodes across Samples.")
	all_tidy[, nShared := 0]
}

if (nrow(sharedBarcodesGrp) > 0){
	sharedBarcodesGrp <- Reduce(rbind,
				 apply(sharedBarcodesGrp, 1, function(x){
				 	all_tidy[prop_Top & bc_id==x['bc_id'] & Group==x['Group'], .(.N, paste(Sample, collapse = " ; ")), by=c("Group", "bc_id")]
				 	})
	)
	setnames(sharedBarcodesGrp, c("group", "bc_id", "nSharedGrp", "Samples"))
	sharedBarcodesGrp <- sharedBarcodesGrp[! bc_id %in% sharedBarcodesGrp[duplicated(bc_id), bc_id], ]  # duplicated barcodes are not unique to the group.
	all_tidy <- merge(all_tidy, sharedBarcodesGrp[, .(bc_id, nSharedGrp)], by="bc_id", all=TRUE)
} else {
	message("No shared Barcodes across Groups.")
	all_tidy[, nSharedGrp := 0]
}

if (nrow(sharedBarcodesTrt) > 0){
	sharedBarcodesTrt <- Reduce(rbind,
				 apply(sharedBarcodesTrt, 1, function(x){
				 	all_tidy[prop_Top & bc_id==x['bc_id'] & Treatment==x['Treatment'], .(.N, paste(Sample, collapse = " ; ")), by=c("Treatment", "bc_id")]
				 	})
	)
	setnames(sharedBarcodesTrt, c("treatment", "bc_id", "nSharedTrt", "Samples"))
	sharedBarcodesTrt <- sharedBarcodesTrt[! bc_id %in% sharedBarcodesTrt[duplicated(bc_id), bc_id], ]  # duplicated barcodes are not unique to the treatment.
	all_tidy <- merge(all_tidy, sharedBarcodesTrt[, .(bc_id, nSharedTrt)], by="bc_id", all=TRUE)
} else {
	message("No shared Barcodes across Treatments.")
	all_tidy[, nSharedTrt := 0]
}


all_tidy[, any_Good := sum(count_Good & refcount_Good) > 0, by=bc_id]
all_tidy[is.na(nShared) & any_Good, nShared := 1]
all_tidy[is.na(nSharedGrp) & any_Good, nSharedGrp := 1]
all_tidy[is.na(nSharedTrt) & any_Good, nSharedTrt := 1]
all_tidy[is.na(nShared) & !any_Good, nShared := 0]
all_tidy[is.na(nSharedGrp) & !any_Good, nSharedGrp := 0]
all_tidy[is.na(nSharedTrt) & !any_Good, nSharedTrt := 0]
```


The colours in the bargraphs below identify enriched barcodes shared across samples. Grey means the barcode is not shared. The barcodes that are below the proportion threshold are represented by the uncoloured top compartment in each stack.

The number of colours that can be distinguished easily by eye is limited, which can be a problem when a large number of barcodes are identified here. If you are unsure whether two colours are the same, hover the mouse pointer over them to verify they have the same `bc_id` value.

## Top barcodes shared across any samples

Enriched in any two or more samples, regardless of group assignment.

```{r complexity2a}
print( sharedBarcodes )
```

```{r complexity_plots2a, fig.widht=7, fig.height=10}
# Prepare colour fill.
all_tidy[, sharedFill := as.character(ifelse(bc_id %in% sharedBarcodes$bc_id, bc_id, 'notshared'))]

# Filter data, then add dummy entries for any samples that have no qualifying barcodes, so they are still shown on the axis.
# Also fill-in a bulk segment for the barcodes that did not meet the threshold.
tmp <- all_tidy[(prop_Top),]
setorder(tmp, -Proportion)
dropped <- unique(all_tidy$Sample)[! unique(all_tidy$Sample) %in% unique(tmp$Sample)]
if(length(dropped) > 0)
  tmp <- rbind(tmp, data.frame(Sample=dropped, bc_id=NA_character_, Reads=0, Proportion=0, count_Good=NA, refcount_Good=NA,
  														 prop_Top=FALSE, Tag=NA_character_, Group=NA_character_, Treatment=NA_character_,
  														 nShared=NA_integer_, nSharedGrp=NA_integer_, nSharedTrt=NA_integer_, any_Good=NA, 
  														 sharedFill=NA_integer_) )
fillup <- tmp[, .(Sample, Proportion)] [, 1-sum(Proportion), by=Sample]
setnames(fillup, c("Sample", "Proportion"))
tmp <- rbind(tmp, cbind(fillup, data.frame(bc_id=NA_character_, Reads=0, count_Good=NA, refcount_Good=NA, prop_Top=FALSE,
																					 Tag=NA_character_, Group=NA_character_, Treatment=NA_character_,
																					 nShared=NA_integer_, nSharedGrp=NA_integer_, nSharedTrt=NA_integer_, 
																					 any_Good=NA, sharedFill='fillup')) )

# Assign colours
elem <- as.character(unique(tmp$sharedFill[!is.na(tmp$sharedFill) & ! tmp$sharedFill %in% c('notshared', 'fillup')]))
if (length(elem) > length(mycolours)){
	warning("There are more barcodes than there are colours in the custom palette! Generating some more colours, Expect difficulty in distinguishing so many colours by eye.")
	elemcol <- getPalette(length(elem))
} else if (length(elem) > 0) {
	# Remove superfluous colours to ensure the notshared and fillup entries get the intended colours.
	elemcol <- mycolours[1:length(elem)]
} else {
	elemcol <- character(0)
}
names(elemcol) <- elem
elemcol["notshared"] <- "grey70"
elemcol["fillup"] <- "grey95"

pcomplex <- ggplot(data=tmp, aes(x=Sample, y=Proportion, fill=sharedFill, group="A", label=bc_id)) +
         geom_bar(stat='identity', position=position_stack(), colour="black", width=0.9, size=0.2) +
         scale_y_continuous(expand = c(0, 0), limits= c(0,1)) +
         scale_fill_manual(values=elemcol, na.value='black') +
         labs(title="Re-occurring enriched barcodes across all samples", x=NULL, y="Proportion of reads") +
         gth + theme(panel.grid.major.x = element_blank(), 
         						legend.position="none")

ggplotly( pcomplex, dynamicTicks = TRUE )
```

## Top barcodes shared within sample groups

Enriched in any two or more samples within each of the designated groups.

```{r complexity2b}
print( sharedBarcodesGrp )
```

```{r complexity_plots2b, fig.widht=7, fig.height=10}
# Prepare colour fill.
all_tidy[, sharedFillGrp := as.character(ifelse(bc_id %in% sharedBarcodesGrp$bc_id, bc_id, 'notshared'))]

# Filter data, then add dummy entries for any samples that have no qualifying barcodes, so they are still shown on the axis.
# Also fill-in a bulk segment for the barcodes that did not meet the threshold.
tmp <- all_tidy[(prop_Top),]
setorder(tmp, -Proportion)
dropped <- unique(all_tidy$Sample)[! unique(all_tidy$Sample) %in% unique(tmp$Sample)]
if(length(dropped) > 0)
  tmp <- rbind(tmp, data.frame(Sample=dropped, bc_id=0, Reads=0, Proportion=0, count_Good=NA, refcount_Good=NA,
  														 prop_Top=FALSE, Tag=NA_character_, Group=NA_character_, Treatment=NA_character_,
  														 nShared=NA_integer_, nSharedGrp=NA_integer_, nSharedTrt=NA_integer_, any_Good=NA, 
  														 sharedFill=NA_integer_, sharedFillGrp=NA_integer_) )
fillup <- tmp[, .(Sample, Proportion)] [, 1-sum(Proportion), by=Sample]
setnames(fillup, c("Sample", "Proportion"))
tmp <- rbind(tmp, cbind(fillup, data.frame(bc_id=-Inf, Reads=0, count_Good=NA,refcount_Good=NA, prop_Top=FALSE,
																					 Tag=NA_character_, Group=NA_character_, Treatment=NA_character_,
																					 nShared=NA_integer_, nSharedGrp=NA_integer_, nSharedTrt=NA_integer_, 
																					 sharedFill=NA_character_, any_Good=NA, sharedFillGrp='fillup')) )

# Assign colours
elem <- as.character(unique(tmp$sharedFillGrp[!is.na(tmp$sharedFillGrp) & ! tmp$sharedFillGrp %in% c('notshared', 'fillup')]))
if (length(elem) > length(mycolours)){
	warning("There are more barcodes than there are colours in the custom palette! Generating some more colours, Expect difficulty in distinguishing so many colours by eye.")
	elemcol <- getPalette(length(elem))
} else if (length(elem) > 0) {
	# Remove superfluous colours to ensure the notshared and fillup entries get the intended colours.
	elemcol <- mycolours[1:length(elem)]
} else {
	elemcol <- character(0)
}
names(elemcol) <- elem
elemcol["notshared"] <- "grey70"
elemcol["fillup"] <- "grey95"

pcomplexGrp <- ggplot(data=tmp, aes(x=Sample, y=Proportion, fill=sharedFillGrp, group="A", label=bc_id)) +
         geom_bar(stat='identity', position=position_stack(), colour="black", width=0.9, size=0.2) +
         scale_y_continuous(expand = c(0, 0), limits= c(0,1),
                            sec.axis = sec_axis(trans = ~ .)) +
         scale_fill_manual(values=elemcol, na.value='black') +
         labs(title="Re-occurring enriched barcodes within a single Group", x=NULL, y="Proportion of reads") +
         gth + theme(panel.grid.major.x = element_blank(), 
         						legend.position="none")

ggplotly( pcomplexGrp, dynamicTicks = TRUE )
```

## Top barcodes shared within treatments

Enriched in any two or more samples within each of the treatments.

```{r complexity2c}
print( sharedBarcodesTrt )
```

```{r complexity_plots2c, fig.widht=7, fig.height=10}
# Prepare colour fill.
all_tidy[, sharedFillTrt := as.character(ifelse(bc_id %in% sharedBarcodesTrt$bc_id, bc_id, 'notshared'))]

# Filter data, then add dummy entries for any samples that have no qualifying barcodes, so they are still shown on the axis.
# Also fill-in a bulk segment for the barcodes that did not meet the threshold.
tmp <- all_tidy[(prop_Top),]
setorder(tmp, -Proportion)
dropped <- unique(all_tidy$Sample)[! unique(all_tidy$Sample) %in% unique(tmp$Sample)]
if(length(dropped) > 0)
  tmp <- rbind(tmp, data.frame(Sample=dropped, bc_id=0, Reads=0, Proportion=0, count_Good=NA, refcount_Good=NA,
  														 prop_Top=FALSE, Tag=NA_character_, Group=NA_character_, Treatment=NA_character_,
  														 nShared=NA_integer_, nSharedGrp=NA_integer_, nSharedTrt=NA_integer_, sharedFill=NA_integer_, 
  														 sharedFillGrp=NA_integer_, any_Good=NA, sharedFillTrt=NA_integer_) )
fillup <- tmp[, .(Sample, Proportion)] [, 1-sum(Proportion), by=Sample]
setnames(fillup, c("Sample", "Proportion"))
tmp <- rbind(tmp, cbind(fillup, data.frame(bc_id=-Inf, Reads=0, count_Good=NA,refcount_Good=NA, prop_Top=FALSE,
																					 Tag=NA_character_, Group=NA_character_, Treatment=NA_character_,
																					 nShared=NA_integer_, nSharedGrp=NA_integer_, nSharedTrt=NA_integer_,
																					 sharedFill=NA_character_, sharedFillGrp=NA_integer_, any_Good=NA, 
																					 sharedFillTrt='fillup')) )

# Assign colours
elem <- as.character(unique(tmp$sharedFillTrt[!is.na(tmp$sharedFillTrt) & ! tmp$sharedFillTrt %in% c('notshared', 'fillup')]))
if (length(elem) > length(mycolours)){
	warning("There are more barcodes than there are colours in the custom palette! Generating some more colours, Expect difficulty in distinguishing so many colours by eye.")
	elemcol <- getPalette(length(elem))
} else if (length(elem) > 0) {
	# Remove superfluous colours to ensure the notshared and fillup entries get the intended colours.
	elemcol <- mycolours[1:length(elem)]
} else {
	elemcol <- character(0)
}
names(elemcol) <- elem
elemcol["notshared"] <- "grey70"
elemcol["fillup"] <- "grey95"

pcomplexTrt <- ggplot(data=tmp, aes(x=Sample, y=Proportion, fill=sharedFillTrt, group="A", label=bc_id)) +
         geom_bar(stat='identity', position=position_stack(), colour="black", width=0.9, size=0.2) +
         scale_y_continuous(expand = c(0, 0), limits= c(0,1),
                            sec.axis = sec_axis(trans = ~ .)) +
         scale_fill_manual(values=elemcol, na.value='black') +
         labs(title="Re-occurring enriched barcodes within a single Treatment", x=NULL, y="Proportion of reads") +
         gth + theme(panel.grid.major.x = element_blank(), 
         						legend.position="none")

ggplotly( pcomplexTrt, dynamicTicks = TRUE )
```



# Enrichment of barcodes

## Most enriching barcodes

For this, every barcode that passes the readcount criterion is ranked by its proportion in each sample and those ranks are then summed for each barcode to give a cumulative rank of enrichment. This does not consider any grouping of the samples.

```{r enriching}
# Use the rank of the barcodes in each sample as a score for interesting-ness. Only interested in barcodes that meed the readcount requirement
all_tidy[, prop_rank := 0]
all_tidy[, cum_rank := 0]
all_tidy[(count_Good), prop_rank := rank(Proportion), by=Sample]
all_tidy[(any_Good), cum_rank := sum(prop_rank, na.rm=TRUE), by=bc_id]

p1 <- ggplot(unique(all_tidy[cum_rank>0, .(bc_id, cum_rank)]), aes(x=cum_rank)) +
	geom_histogram(bins=min(max(all_tidy$cum_rank)/2, 200)) +
	labs(x="Cumulative rank", y="Barcodes") +
	theme_light()

DF <- unique(all_tidy[, .(bc_id, cum_rank, nShared, nSharedGrp, nSharedTrt)])
setorder(DF, -cum_rank)

print( DF[cum_rank > quantile(DF$cum_rank, 0.995), ] )

print(p1)
# ggplotly(p1, dynamicTicks=TRUE)
```

```{r table2}
# Spread abundances to wide format
DF <- dcast(all_tidy, bc_id + cum_rank + nShared + nSharedGrp + nSharedTrt ~ Sample, value.var=c("Reads", "Proportion"))
DF <- merge(counts[, .(bc_id, barcode)], DF, by="bc_id", all=TRUE)
setorder(DF, -cum_rank)

fwrite(DF, file=paste0(params$outpref, '_data.tsv'), sep="\t", quote=FALSE)
```

## Expression heatmap of most enriching barcodes

All the barcodes that meet the proportion threshold in at least one sample.

```{r enrichment, fig.height=15}
top <- unique(all_tidy[(prop_Top), .(bc_id)])

pheat <- all_tidy %>%
  arrange(bc_id) %>%
  filter(bc_id %in% top$bc_id) %>%
  select(Sample, bc_id, Proportion) %>%
  mutate(bc_id=factor(as.character(bc_id), levels=as.character(top$bc_id))) %>%
  ggplot(aes(x=Sample, y=bc_id, fill=Proportion)) +
    geom_tile(colour='transparent') +
    labs(x='') +
    theme(axis.text.x=element_text(angle=90, vjust=0.5, hjust=1),
          panel.background = element_rect(fill="white"),
          panel.grid.major = element_line(colour="grey95"))

ggplotly( pheat, dynamicTicks = TRUE )
```

## Distribution of top interesting barcodes

This section identifies the abundance of each selected barcode (white diamonds and white violin/box-plot) against the distribution of all barcodes (coloured violin/box-plots).

```{r enrichment_shared}
pviolas <- lapply(unique(all_tidy[nSharedGrp > 1 | nSharedTrt >1, bc_id]), function(bc) {
  # bc <- interestingbcs[1]

  # Create dummy sample with the abundances of the given barcode only.
  # Preserve sample order.
  tmp <- all_tidy[(bc_id==bc),]
  bct <- paste("bc:", bc)
  tmp$Sample <- factor(bct, levels=c(sampleNames, bct), ordered=TRUE)
  tmp$Treatment <- "bc"
  tmp2 <- all_tidy[(count_Good),]
  tmp2$Sample <- factor(tmp2$Sample, levels=c(sampleNames, bct), ordered=TRUE)
  tmp <- rbind(tmp2, tmp)

  print(paste('Barcode', bc))
  print(counts$barcode[counts$bc_id==bc])
  
  p <- ggplot(data=tmp, aes(x=Sample, y=Proportion, fill=Treatment)) +
      geom_hline(yintercept=abund_thresh, linetype='dotted') +
      geom_violin() +
      geom_boxplot(fill='white', width=0.15, outlier.size = 0.8, outlier.alpha = 0.5, alpha=0.4) +
      geom_point(data=all_tidy[(bc_id == bc), ], fill=treatCols['bc'], size=2.2, shape=23) +
      scale_y_log10() +
      scale_fill_manual(values=treatCols) +
  		annotation_logticks(base=10, sides='lr') +
      labs(title=paste("Abundance of barcode",bc), x='') +
      gth + theme(panel.grid.minor.y = element_line(colour='grey95'))
  
	print( p )
	return( p )
})

```

## Distribution of manually selected barcodes

```{r enrichment_manual}
pviolas2 <- NULL
if (is.null(params$extra_bc)) {
  cat("No additional barcodes selected")
} else {
	pviolas2 <- lapply(params$extra_bc, function(bc) {
	  # bc <- sharedBarcodes$bc_id[1]

	  # Create dummy sample with the abundances of the given barcode only.
	  # Preserve sample order.
	  tmp <- all_tidy[(bc_id==bc),]
	  bct <- paste("bc:", bc)
	  tmp$Sample <- factor(bct, levels=c(sampleNames, bct), ordered=TRUE)
	  tmp$treatment <- "bc"
	  tmp2 <- all_tidy[(count_Good),]
	  tmp2$Sample <- factor(tmp2$Sample, levels=c(sampleNames, bct), ordered=TRUE)
	  tmp <- rbind(tmp2, tmp)

	  print(paste('Barcode', bc))
	  print(counts$barcode[counts$bc_id==bc])
	  
	  p <- ggplot(data=tmp, aes(x=Sample, y=Proportion, fill=treatment)) +
	      geom_hline(yintercept=abund_thresh, linetype='dotted') +
	      geom_violin() +
	      geom_boxplot(fill='white', width=0.15, outlier.size = 0.8, outlier.alpha = 0.5, alpha=0.4) +
	      geom_point(data=all_tidy[(bc_id == bc), ], fill=treatCols['bc'], size=2.2, shape=23) +
	      scale_y_log10() +
	      scale_fill_manual(values=treatCols) +
	      annotation_logticks(base=10, sides='lr') +
      	labs(paste("Abundance of barcode",bc), x='') +
	      gth + theme(panel.grid.minor.y = element_line(colour='grey95'))
	  
	  print( p )
	  return( p )
	})
}
```

# Barcode sequence similarity

If merging of the barcodes by Hamming distance was enabled during processing, the frequency of
pair-wise barcode similarity levels, as measured by the edit distance, will be shown in this
section. Each barcode pair is counted once, and all the possible pairs are counted. The values
tracked are the number of barcode pairs in each distance bin and the respective numbers of reads.

```{r}
if (is.null(params$hammdist)) {
  cat("No info available")
} else {
  library(ggridges)

  hammdist[, clr := vapply(as.character(hammdist$Sample), function(x) { samples_tidy[name==x, colour] }, character(1)) ]

  pham1 <- ggplot(hammdist, aes(x=HammDist, y=Sample, height=sqrt(BCs), colour=clr, fill=clr) ) +
    geom_density_ridges(stat="identity", scale=1, alpha=0.5) +
    scale_colour_identity() +
    scale_fill_identity() +
    labs(title="Distribution of pairwise barcode distances", x = "Hamming distance") +
    gth + theme(axis.text.x = element_text(angle=0))


  pham2 <- ggplot(hammdist, aes(x=HammDist, group=Sample, y=BCs, colour=clr) ) +
    geom_line() +
    scale_colour_identity() +
    scale_fill_identity() +
    labs(x = "Hamming distance", y="Number of barcode pairs") +
    gth + theme(axis.text.x = element_text(angle=0))
  pham3 <- pham2 +
    scale_y_log10() +
    annotation_logticks(base=10, sides='lr') +
    labs(y='')
  
  print( pham1 )
  print(pham2 + pham3)
}
```

# Session Info

```{r}
sessionInfo()
```



```{r pdf, include=FALSE}
pdf(paste0(params$outpref, '_report.pdf'), paper="a4", width=7, height=10)

print( pdemux )
print( pcount )
print( pcount + scale_y_continuous(expand = expand_scale(mult = c(0, .15)), limits = c(0, NA), trans='sqrt') )
print( cplots[["drnc"]] )
print( cplots[["frc"]] )
# print ( pviol )      # For some reason pviol breaks between point of its creation and here. So just reimplement it below.
print( all_tidy %>%
  filter(count_Good) %>%
  ggplot(aes(x=Sample, y=Proportion)) +
    geom_violin(aes(fill=Treatment), width=1) +
    geom_boxplot(fill="white", width=0.1, outlier.colour="transparent") +
    geom_hline(yintercept = abund_thresh, linetype='dotted') +
    scale_y_log10() +
		annotation_logticks(base=10, sides='lr') +
    scale_fill_manual(values=treatCols) +
    labs(title="Barcode abundances", subtitle=paste("for barcodes with at least", count_thresh, "reads"), x='') +
		gth
)
print( pcomplex )
print( pcomplexGrp )
print( pcomplexTrt )
print( pcomplex2 + geom_label_repel(nudge_x=100, min.segment.length = 0))
print( pheat )
print(pviolas)
if (!is.null(pviolas2)) {
	print(pviolas2)
}
if (!is.null(params$hammdist)) {
	print( pham1 )
  print( pham2 / pham3 )
}

dev.off()
```
